<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>glTF Loader</title>
    <script src="https://developer.letsee.io/api/webar?key=598fd5bd3ec4e258d90b37f37e33992a529071e346560189fcc83e31e46b7218"></script>
    <script src="https://unpkg.com/three@0.121.1/build/three.min.js"></script>
    <script src="https://intra.letsee.io:10001/1.1.0/wzwg/js/lib/r120/GLTFLoader.js"></script>

    <style media="place" type="text/css">
        #container {
            -letsee-target: uri('toystory.json');
            width: 140px;
            height: 200px;
            z-index: 300;
            border: 1px solid red;
        }
    </style>

</head>
<body>
    <div id="container">

    </div>
    <script type="module">

        import {Either, Left, Right, EntityFactory} from './assets/js/EntityFactory.js';

        let basePath = 'https://intra.letsee.io/3D-model/gltf/EMC/';

        let files = [
            basePath+'20201114/B_take_06/B_take_06.gltf',
            basePath+'20201124/C_take_06/C_take_06.gltf',
        ];

        let data = {
            fileName: '',
            animations: new Array(),
            meshInfos: new Array(),
            renderInfo: null,
            checkMorph: function() {
                let result = {
                    fileName: data.fileName,
                    animations: data.animations,
                    morphs: null
                };
                let arr = new Array();
                data.meshInfos.forEach(info => {
                    let compare = new Array();
                    const attr = info.morphAttributes;
                    const length = attr.normal.length | attr.position.length;
                    for (let i = 0; i < length; i++) {
                        const t1 = attr.normal[i];
                        const t2 = attr.position[i];
                        compare.push(t1.array.every((val, index) => val === t2.array[index]));
                    }
                    arr.push({name: info.name, compare:compare});
                });
                result.morphs = arr;
                return result;
            }
        };

        let currentFileName = '';

        let scene, camera, renderer, entity, mesh, mixer, action, id, clock;

        let glTFLoader = new THREE.GLTFLoader();

        let flag = true;

        letsee.ready(() => {
            letsee.start();
            letsee.addTHREE(THREE)
                .then(obj => {
                    return new Promise((resolve) => {
                        scene = obj.scene;
                        camera = obj.camera;
                        renderer = obj.renderer;
                        renderer.toneMappingExposure = 1;
                        renderer.outputEncoding = THREE.sRGBEncoding;
                        clock = new THREE.Clock();
                        resolve(addLightToScene(scene));
                    });
                })
                .then(_scene => {
                    return EntityFactory.addEntity('toystory.json');
                })
                .then(_entity => {
                    entity = _entity.value();
                    data.fileName = currentFileName = files[0];
                    glTFLoader.load(currentFileName, onLoad, onProgress, onError);
                    renderAll();
                })
            ;
        });
        letsee.init();

        const addLightToScene = (scene) => {
            let _scene = scene;

            let ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            ambientLight.position.set(0, 0, 0);

            let dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(-0.5, 0.5, 0.866);
            dirLight.castShadow = false;
            dirLight.shadow.mapSize = new THREE.Vector2(512, 512);

            // let spotLight = new THREE.SpotLight(0xeeeeee, 5);
            // spotLight.position.set(2, -5, 10);
            // spotLight.castShadow = true;

            _scene.add(ambientLight);
            _scene.add(dirLight);

            return _scene;
        }

        const onLoad = (gltf) => {

            mesh = gltf.scene;

            mesh.position.set(0, 0, 0);
            mesh.rotation.set(70, 45, 0);
            mesh.visible = true;
            mesh.tag = files[0];
            mesh.name = files[0];
            mesh.scale.setScalar(1);

            // Play model's animation
            if (gltf.animations.length > 0) {
                data.animations.push(gltf.animations);
                mixer = new THREE.AnimationMixer(gltf.scene);
                action = mixer.clipAction(gltf.animations[0]);
                action.play();
            }

            mesh.add(new THREE.AxesHelper(300));

            //Get center point of the model
            mesh.children.forEach(child => {
                child.traverse(function (obj) {
                    switch (obj.type) {
                        case 'Mesh':            obj.geometry.center();                      break;
                        case 'SkinnedMesh':
                            // data.skinnedMeshes.push(obj);
                            const _infos = {
                                name: obj.userData.name,
                                type: obj.type,
                                geometry: { attributes: obj.geometry.attributes },
                                morphAttributes: obj.geometry.morphAttributes,
                                morphTargetsRelative: obj.geometry.morphTargetsRelative,
                            };
                            if (_infos.morphTargetsRelative) data.meshInfos.push(_infos);
                            break;
                        default:
                            break;
                    }
                })
            })

            entity.add(mesh);

            // add entity to scene
            scene.add(entity);
        };

        const onError = (e) => {
            console.error(e);
        };

        // Show the progress of loading model
        const onProgress = (xhr) => {
            if (xhr.lengthComputable) {
                const percentComplete = xhr.loaded / xhr.total * 100;

                if (Math.round(percentComplete) === 100) {
                    console.warn(percentComplete);
                }
            }
        }

        // Render all
        const renderAll = async function () {
            requestAnimationFrame(renderAll);
            if (mixer) {
                let delta = clock.getDelta();
                mixer.update(delta);
            }
            await letsee.threeRenderer().update(); // Engine mainLoop 수행
            const _camera = letsee.threeRenderer().getDeviceCamera(); // 매 프레임마다 카메라 얻어옴.
            renderer.render(scene, _camera);
            if (flag && renderer.info.memory.geometries > 0) {
                data.renderInfo = renderer.info;
                window.modelData = data;
                console.warn(window.modelData);
                if (data.renderInfo.memory.geometries > 0) flag = false;
            }
        };

    </script>
</body>
</html>
